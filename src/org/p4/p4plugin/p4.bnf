{
  parserClass="org.p4.p4plugin.parser.P4LangParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="P4Lang"
  psiImplClassSuffix="Impl"
  psiPackage="org.p4.p4plugin.psi"
  psiImplPackage="org.p4.p4plugin.psi.impl"
  elementTypeHolderClass="org.p4.p4plugin.psi.P4LangTypes"
  elementTypeClass="org.p4.p4plugin.psi.P4LangElementType"
  tokenTypeClass="org.p4.p4plugin.psi.P4LangTokenType"
}

tokens ::= [
    END UNEXPECTED_TOKEN COMMENT
    LE GE
    SHL AND OR NOT
    NE EQ
    PLUS MINUS MUL DIV MOD
    BIT_OR BIT_AND BIT_XOR COMPLEMENT
    L_BRACKET R_BRACKET L_BRACE R_BRACE L_ANGLE R_ANGLE L_PAREN R_PAREN
    COLON COMMA QUESTION DOT ASSIGN SEMICOLON AT
    PP DONTCARE MASK RANGE TRUE FALSE THIS
    ABSTRACT ACTION ACTIONS APPLY BOOL BIT CONST
    CONTROL DATA DEFAULT ELSE ENTRIES ENUM ERROR
    EXIT EXTERN HEADER HEADER_UNION IF IN
    INOUT INT KEY SELECT MATCH_KIND OUT
    PACKAGE PARSER RETURN STATE STRUCT SWITCH TABLE TRANSITION
    TUPLE TYPEDEF VARBIT VOID IDENTIFIER TYPE STRING_LITERAL INTEGER
]

program ::= input END ;
input ::=
      /* epsilon */
    | input declaration
    | input ";"    // empty declaration
    ;
declaration ::=
      constantDeclaration
    | externDeclaration
    | actionDeclaration
    | parserDeclaration
    | typeDeclaration
    | controlDeclaration
    | instantiation
    | errorDeclaration
    | matchKindDeclaration
    ;
nonTypeName ::=
      IDENTIFIER
    | APPLY
    | KEY
    | ACTIONS
    | STATE
    | ENTRIES
    ;
p4ItemName ::=
     nonTypeName
    | TYPE
    ;
optCONST ::=
     /* empty */
    | CONST
    ;
optAnnotations ::=
     /* empty */
    | annotations
    ;
annotations ::=
     annotation
    | annotations annotation
    ;
annotation ::=
     "@" p4ItemName
    | "@" p4ItemName "(" expressionArray ")"
    ;
parameterArray ::=
     /* empty */
    | nonEmptyParameterArray
    ;
nonEmptyParameterArray ::=
     parameter
    | nonEmptyParameterArray "," parameter
    ;
parameter ::=
     optAnnotations direction typeRef p4ItemName
    ;
direction ::=
     IN
    | OUT
    | INOUT
    | /* empty */
    ;
packageTypeDeclaration ::=
     optAnnotations PACKAGE p4ItemName
      optTypeParameters
      "(" parameterArray ")"
    ;
instantiation ::=
        annotations typeRef "(" argumentArray ")" p4ItemName ";"
      | typeRef "(" argumentArray ")" p4ItemName ";"
      /* experimental */
      | annotations typeRef "(" argumentArray ")" p4ItemName "=" objInitializer ";"
      /* experimental */
      | typeRef "(" argumentArray ")" p4ItemName "=" objInitializer ";"
    ;
/* experimental; includes the following 3 productions */
objInitializer ::=
     "{" objDeclarations "}"
    ;
objDeclarations ::=
     /* empty */
    | objDeclarations objDeclaration
    ;
objDeclaration ::=
     functionDeclaration
    | instantiation
    ;
optConstructorParameters ::=
     /* empty */
    | "(" parameterArray ")"
    ;
dotPrefix ::=
     "."
    ;
/**************************** PARSER ******************************/
parserDeclaration ::=
     parserTypeDeclaration optConstructorParameters
      "{" parserLocalElements parserStates "}"
    ;
parserLocalElements ::=
     /* empty */
    | parserLocalElements parserLocalElement
    ;
parserLocalElement ::=
     constantDeclaration
    | instantiation
    | variableDeclaration
    ;
parserTypeDeclaration ::=
     optAnnotations
        PARSER p4ItemName
        optTypeParameters
        "(" parameterArray ")"
    ;
parserStates ::=
     parserState
    | parserStates parserState
    ;
parserState ::=
     optAnnotations STATE p4ItemName
      "{" parserStatements transitionStatement "}"
    ;
parserStatements ::=
     /* empty */
    | parserStatements parserStatement
    ;
parserStatement ::=
     assignmentOrMethodCallStatement
    | directApplication
    | variableDeclaration
    | constantDeclaration
    | parserBlockStatement
    ;
parserBlockStatement ::=
     optAnnotations "{" parserStatements "}"
    ;
transitionStatement ::=
     /* empty */
    | TRANSITION stateExpression
    ;
stateExpression ::=
     p4ItemName ";"
    | selectExpression
    ;
selectExpression ::=
     SELECT "(" expressionArray ")" "{" selectCaseArray "}"
    ;
selectCaseArray ::=
     /* empty */
    | selectCaseArray selectCase
    ;
selectCase ::=
     keysetExpression ":" p4ItemName ";"
    ;
keysetExpression ::=
     tupleKeysetExpression
    | simpleKeysetExpression
    ;
tupleKeysetExpression
    /* at least two elements in the tuple */ ::=
     "(" simpleKeysetExpression "," simpleExpressionArray ")"
    ;
simpleExpressionArray ::=
     simpleKeysetExpression
    | simpleExpressionArray "," simpleKeysetExpression
    ;
simpleKeysetExpression ::=
     expression
    | expression "&&&" expression
    | expression ".." expression
    | DEFAULT
    | "_"
    ;
/*************************** CONTROL ************************/
controlDeclaration ::=
     controlTypeDeclaration optConstructorParameters
      "{" controlLocalDeclarations APPLY controlBody "}"
    ;
controlTypeDeclaration ::=
     optAnnotations
        CONTROL p4ItemName
        optTypeParameters
        "(" parameterArray ")"
    ;
controlLocalDeclarations ::=
     /* empty */
    | controlLocalDeclarations controlLocalDeclaration
    ;
controlLocalDeclaration ::=
     constantDeclaration
    | actionDeclaration
    | tableDeclaration
    | instantiation
    | variableDeclaration
    ;
controlBody ::=
     blockStatement
    ;
/*************************** EXTERN *************************/
externDeclaration ::=
     optAnnotations
        EXTERN nonTypeName
        optTypeParameters
        "{" methodPrototypes "}"
    | optAnnotations EXTERN functionPrototype ";"
    | optAnnotations EXTERN p4ItemName ";"
    ;
methodPrototypes ::=
     /* empty */
    | methodPrototypes methodPrototype
    ;
functionPrototype ::=
     typeOrVoid
        p4ItemName optTypeParameters
        "(" parameterArray ")"
    ;
methodPrototype ::=
     optAnnotations functionPrototype ";"
    | optAnnotations ABSTRACT functionPrototype ";"     // experimental
    | optAnnotations TYPE "(" parameterArray ")" ";"  // constructor
    ;
/************************** TYPES ****************************/
typeRef ::=
     baseType
    | typeName
    | specializedType
    | headerStackType
    | tupleType
    ;
prefixedType ::=
     TYPE
    | dotPrefix TYPE
    ;
typeName ::=
     prefixedType
    ;
tupleType ::=
     TUPLE "<" typeArgumentArray ">"
    ;
headerStackType ::=
     typeName "[" expression "]"
    ;
specializedType ::=
     typeName "<" typeArgumentArray ">"
    ;
baseType ::=
     BOOL
    | ERROR
    | BIT
    | BIT "<" INTEGER ">"
    | INT "<" INTEGER ">"
    | VARBIT "<" INTEGER ">"
    ;
typeOrVoid ::=
     typeRef
    | VOID
    | nonTypeName
        // This is necessary because template arguments may introduce the return type
    ;
optTypeParameters ::=
     /* empty */
    | "<" typeParameterArray ">"
    ;
typeParameterArray ::=
     p4ItemName
    | typeParameterArray "," p4ItemName
    ;
typeArg ::=
     typeRef
    | "_"
    ;
typeArgumentArray ::=
     typeArg
    | typeArgumentArray "," typeArg
    ;
typeDeclaration ::=
     derivedTypeDeclaration
    | typedefDeclaration ";"
    | parserTypeDeclaration ";"
    | controlTypeDeclaration ";"
    | packageTypeDeclaration ";"
    ;
derivedTypeDeclaration ::=
     headerTypeDeclaration
    | headerUnionDeclaration
    | structTypeDeclaration
    | enumDeclaration
    ;
headerTypeDeclaration ::=
     optAnnotations
        HEADER p4ItemName
        "{" structFieldArray "}"
    ;
structTypeDeclaration ::=
     optAnnotations
        STRUCT p4ItemName
        "{" structFieldArray "}"
    ;
// experimental
headerUnionDeclaration ::=
     optAnnotations
        HEADER_UNION p4ItemName
        "{" structFieldArray "}"
    ;
structFieldArray ::=
     /* empty */
    | structFieldArray structField
    ;
structField ::=
     optAnnotations typeRef p4ItemName ";"
    ;
enumDeclaration ::=
     optAnnotations
        ENUM p4ItemName
        "{" identifierArray "}"
    ;
errorDeclaration ::=
     ERROR "{" identifierArray "}"
    ;
matchKindDeclaration ::=
     MATCH_KIND "{" identifierArray "}"
    ;
identifierArray ::=
     p4ItemName
    | identifierArray "," p4ItemName
    ;
typedefDeclaration ::=
     optAnnotations TYPEDEF typeRef p4ItemName
    | optAnnotations TYPEDEF derivedTypeDeclaration p4ItemName
    ;
/*************************** STATEMENTS *************************/
assignmentOrMethodCallStatement ::=
    // These rules are overly permissive, but they avoid some conflicts
      lvalue "(" argumentArray ")" ";"
    | lvalue "<" typeArgumentArray ">" "(" argumentArray ")" ";"
    | lvalue "=" expression ";"
    ;
emptyStatement ::=
     ";"
    ;
exitStatement ::= EXIT ";" ;
returnStatement ::=
     RETURN ";"
    | RETURN expression ";"
    ;
conditionalStatement ::=
     IF "(" expression ")" statement
    | IF "(" expression ")" statement ELSE statement
    ;
// To support direct invocation of a control or parser without instantiation
directApplication ::=
     typeName "." APPLY "(" argumentArray ")" ";"
    ;
statement ::=
      assignmentOrMethodCallStatement
    | directApplication
    | conditionalStatement
    | emptyStatement
    | blockStatement
    | returnStatement
    | exitStatement
    | switchStatement
    ;
blockStatement ::=
     optAnnotations "{"
      statOrDeclArray "}"
    ;
statOrDeclArray ::=
     /* empty */
    | statOrDeclArray statementOrDeclaration
    ;
switchStatement ::=
     SWITCH "(" expression ")" "{" switchCases "}"
    ;
switchCases ::=
     /* empty */
    | switchCases switchCase
    ;
switchCase ::=
     switchLabel ":" blockStatement
    | switchLabel ":"
    ;
switchLabel ::=
     p4ItemName
    | DEFAULT
    ;
statementOrDeclaration ::=
     variableDeclaration
    | constantDeclaration
    | statement
    | instantiation
    ;
/************************* TABLE *********************************/
tableDeclaration ::=
     optAnnotations
        TABLE p4ItemName "{" tablePropertyArray "}"
    ;
tablePropertyArray ::=
     tableProperty
    | tablePropertyArray tableProperty
    ;
tableProperty ::=
     KEY "=" "{" keyElementArray "}"
    | ACTIONS "=" "{" actionArray "}"
    | optAnnotations optCONST ENTRIES "=" "{" entriesArray "}"
    | optAnnotations optCONST IDENTIFIER "=" initializer ";"
    ;
keyElementArray ::=
     /* empty */
    | keyElementArray keyElement
    ;
keyElement ::=
     expression ":" p4ItemName optAnnotations ";"
    ;
actionArray ::=
     /* empty */
    | actionArray actionRef ";"
    ;
actionRef ::=
     optAnnotations p4ItemName
    | optAnnotations p4ItemName "(" argumentArray ")"
    ;
entry ::=
     keysetExpression ":" actionBinding optAnnotations ";"
    ;
actionBinding ::=
     lvalue "(" argumentArray ")"

    | lvalue "<" typeArgumentArray ">" "(" argumentArray ")"
entriesArray ::=
     entry
    | entriesArray entry
    ;
/************************* ACTION ********************************/
actionDeclaration ::=
     optAnnotations ACTION p4ItemName "(" parameterArray ")" blockStatement
    ;
/************************* VARIABLES *****************************/
variableDeclaration ::=
     annotations typeRef p4ItemName optInitializer ";"
    | typeRef p4ItemName optInitializer ";"
    ;
constantDeclaration ::=
     optAnnotations CONST typeRef p4ItemName "=" initializer ";"
    ;
optInitializer ::=
     /* empty */
    | "=" initializer
    ;
initializer ::=
     expression
    ;
/**************** Expressions ****************/
// experimental
functionDeclaration ::=
     functionPrototype blockStatement
    ;
argumentArray ::=
     /* empty */
    | nonEmptyArgArray
    ;
nonEmptyArgArray ::=
     argument
    | nonEmptyArgArray "," argument
    ;
argument ::=
     expression
    | "_"
    ;
expressionArray ::=
     /* empty */
    | expression
    | expressionArray "," expression
    ;
prefixedNonTypeName ::=
     nonTypeName
    | dotPrefix nonTypeName
    ;
lvalue ::=
     prefixedNonTypeName
    | THIS                                // experimental
    | lvalue "." p4ItemName
    | lvalue "[" expression "]"
    | lvalue "[" expression ":" expression "]"
    ;
expression ::=
     INTEGER
    | STRING_LITERAL
    | TRUE
    | FALSE
    | THIS                                // experimental
    | nonTypeName
    | "." nonTypeName
    | expression "[" expression "]"
    | expression "[" expression ":" expression "]"
    | "{" expressionArray "}"
    | "(" expression ")"
    | "!" expression
    | "~" expression
    | "-" expression
    | "+" expression
    | typeName "." p4ItemName
    | ERROR "." p4ItemName
    | expression "." p4ItemName
    | expression "*" expression
    | expression "/" expression
    | expression "%" expression
    | expression "+" expression
    | expression "-" expression
    | expression "<<" expression
    | expression ">" ">" expression
    | expression "<=" expression
    | expression ">=" expression
    | expression "<" expression
    | expression ">" expression
    | expression "!=" expression
    | expression "==" expression
    | expression "&" expression
    | expression "^" expression
    | expression "|" expression
    | expression "++" expression
    | expression "&&" expression
    | expression "||" expression
    | expression "?" expression ":" expression
    | expression "<" typeArgumentArray ">" "(" argumentArray ")"
    // FIXME: the previous rule has the wrong precedence, and parses with
    // precedence weaker than casts.  There is no easy way to fix this in bison.
    | expression "(" argumentArray ")"
    | typeRef "(" argumentArray ")"
    | "(" typeRef ")" expression
    ;
